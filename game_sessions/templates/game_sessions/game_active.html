{% extends 'base.html' %}

{% block title %}Game Active - {{ game_session.game_code }}{% endblock %}

{% block content %}
<style>
/* Override base template container constraints for full width */
.container {
    max-width: none !important;
    padding: 10px !important;
    margin: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    box-sizing: border-box;
    overflow-y: auto;
}

body {
    margin: 0 !important;
    padding: 0 !important;
    height: 100vh;
    overflow: hidden;
    max-width: none !important;
    width: 100vw !important;
}

/* Override any inherited width constraints */
html, body, .container, #game-state {
    max-width: none !important;
    width: 100% !important;
}

/* Make round header more compact and full width */
.round-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.round-title h2 {
    margin: 0;
    font-size: 1.5em;
    font-weight: bold;
}

.player-count {
    color: #6c757d;
    font-weight: bold;
    font-size: 1em;
}

/* Optimize pre-game layout for better space usage */
.game-code {
    padding: 12px !important;
    margin: 10px 0 !important;
    font-size: 1.6em !important;
}

.game-config {
    padding: 8px !important;
    margin: 10px 0 !important;
}

.player-list {
    padding: 8px !important;
    margin: 10px 0 !important;
    max-height: 150px;
    overflow-y: auto;
}

/* Larger QR code for easier scanning */
.game-code img {
    max-width: 250px !important;
    width: 100%;
    height: auto;
}

.game-code p {
    margin: 5px 0 !important;
    font-size: 0.8em !important;
}

/* Pre-game dashboard layout optimization */
.pre-game-dashboard {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    align-items: start;
}

.pre-game-left {
    display: flex;
    flex-direction: column;
}

.pre-game-right {
    display: flex;
    flex-direction: column;
}

/* Compact buttons and controls */
.game-controls {
    margin: 10px 0 !important;
}

.game-controls .btn {
    margin: 3px !important;
    padding: 8px 16px !important;
    font-size: 0.9em !important;
}

/* Make player list more compact */
.player-item {
    padding: 3px 0 !important;
    font-size: 0.9em;
}

.player-list h4 {
    margin: 0 0 8px 0 !important;
    font-size: 1.1em;
}

/* Dashboard title more compact */
.text-center h2 {
    margin: 10px 0 !important;
    font-size: 1.8em;
}
</style>

<div id="game-state">
    {% if game_session.status == 'waiting' %}
        <!-- Pre-game waiting state -->
        <div class="text-center">
            <h2>üéØ Game Master Dashboard</h2>
        </div>
        
        <div class="pre-game-dashboard">
            <div class="pre-game-left">
                <div class="game-code" style="background: #e3f2fd; border-radius: 8px;">
                    <h3 style="margin: 0 0 8px 0; font-size: 1.4em;">Game Code: {{ game_session.game_code }}</h3>
                    
                    <!-- QR Code for joining -->
                    <div style="margin: 8px 0;">
                        <img src="data:image/png;base64,{{ qr_code_base64 }}" alt="QR Code to join game">
                        <p>
                            <strong>Join URL:</strong> <a href="{{ join_url }}" target="_blank">{{ join_url }}</a>
                        </p>
                        <p style="color: #666;">
                            Server: {{ server_ip }}:8000
                        </p>
                    </div>
                </div>
                
                {% if config %}
                    <div class="game-config" style="background: #f8f9fa; border-radius: 6px;">
                        <h4 style="margin: 0 0 5px 0; font-size: 1.1em;">üéØ Game Configuration</h4>
                        <p style="margin: 3px 0;"><strong>Game Type:</strong> {{ config.game_type.name }}</p>
                        <p style="margin: 3px 0;"><strong>Rounds:</strong> {{ config.num_rounds }} | <strong>Time per Round:</strong> {{ config.round_time_seconds }}s</p>
                    </div>
                {% endif %}
            </div>
            
            <div class="pre-game-right">
                <div class="player-list" style="background: #f8f9fa; border-radius: 6px;">
                    <h4>Connected Players (<span class="player-count">{{ player_count }}</span>/{{ game_session.max_players }})</h4>
                    <div id="player-list-content">
                        {% if players %}
                            {% for player in players %}
                                <div class="player-item" style="border-bottom: 1px solid #eee;">
                                    <strong>{{ player.name }}</strong>
                                    <small style="color: #666;"> - Joined {{ player.joined_at|date:"H:i:s" }}</small>
                                </div>
                            {% endfor %}
                        {% else %}
                            <p style="color: #666; font-style: italic; margin: 5px 0;">No players have joined yet.</p>
                        {% endif %}
                    </div>
                </div>
                
                {% if config %}
                    <div class="game-controls">
                        <div id="start-game-container">
                            <button id="start-game-btn" class="btn btn-success" {% if player_count == 0 %}style="display: none;"{% endif %}>
                                üöÄ Start Game
                            </button>
                            <button id="waiting-for-players-btn" class="btn" disabled {% if player_count > 0 %}style="display: none;"{% endif %}>
                                Waiting for players to join...
                            </button>
                        </div>
                        <a href="{% url 'game_sessions:configure_game' game_session.game_code %}" class="btn">
                            ‚öôÔ∏è Reconfigure Game
                        </a>
                    </div>
                {% else %}
                    <div class="game-controls">
                        <a href="{% url 'game_sessions:configure_game' game_session.game_code %}" class="btn btn-success">
                            ‚öôÔ∏è Configure Game First
                        </a>
                    </div>
                {% endif %}
                
                <!-- Move dev buttons to be always visible -->
                <div class="game-controls" style="border-top: 1px solid #dee2e6; padding-top: 8px; margin-top: 10px;">
                    <button id="restart-game-btn" class="btn" style="font-size: 0.8em; padding: 6px 12px;">
                        üîÑ Restart Game (Dev)
                    </button>
                    <a href="{% url 'game_sessions:home' %}" class="btn" style="font-size: 0.8em; padding: 6px 12px;">‚Üê Back to Home</a>
                </div>
            </div>
        </div>
    {% elif game_session.status == 'finished' %}
        <!-- Game finished state -->
        <div class="text-center">
            <h2>üèÅ Game Finished!</h2>
            <p>Thank you for playing!</p>
        </div>
    {% elif game_session.current_round_number > 0 %}
        {% with round_info=game_session.get_current_round_info %}
            <div id="round-display">
                <div class="round-header">
                    <div class="round-title">
                        <h2>Round {{ round_info.round_number }} of {{ config.num_rounds }}</h2>
                        <span class="player-count">{{ player_count }} players</span>
                    </div>
                    <div class="round-details">
                        {% if round_info.round_type == 'flower_fruit_veg' %}
                            <span class="category">{{ round_info.category.name|default:round_info.category }}</span>
                            <span class="letter">Letter: {{ round_info.prompt_letter }}</span>
                        {% elif round_info.round_type == 'multiple_choice' %}
                            <span class="category">{{ round_info.category|default:"Multiple Choice" }}</span>
                        {% elif round_info.round_type == 'mastermind' %}
                            {% if round_info.state == 'waiting_for_player_selection' %}
                                <span class="mastermind-state" style="background: #FF9800; color: white; padding: 5px 15px; border-radius: 20px;">‚è≥ Select Player</span>
                            {% elif round_info.state == 'asking_ready' %}
                                <span class="mastermind-state" style="background: #2196F3; color: white; padding: 5px 15px; border-radius: 20px;">‚ùì {{ round_info.current_player.name }} - Ready Check</span>
                            {% elif round_info.state == 'playing' %}
                                <span class="mastermind-player" style="background: #9C27B0; color: white; padding: 5px 15px; border-radius: 20px;">üß† {{ round_info.current_player.name }} (Q{{ round_info.current_question_index }}/{{ round_info.questions_per_player }})</span>
                            {% elif round_info.state == 'player_complete' %}
                                <span class="mastermind-state" style="background: #4CAF50; color: white; padding: 5px 15px; border-radius: 20px;">‚úÖ {{ round_info.current_player.name }} Complete</span>
                            {% elif round_info.phase == 'general' %}
                                <span class="mastermind-phase" style="background: #FF5722; color: white; padding: 5px 15px; border-radius: 20px;">üìö General Knowledge</span>
                            {% else %}
                                <span class="mastermind-state" style="background: #607D8B; color: white; padding: 5px 15px; border-radius: 20px;">üß† Mastermind</span>
                            {% endif %}
                        {% endif %}
                    </div>
                </div>
                <div class="game-prompt">
                    {% if round_info.round_type == 'flower_fruit_veg' %}
                        {{ round_info.category.name|default:round_info.category }} that start with {{ round_info.prompt_letter }}
                    {% elif round_info.round_type == 'multiple_choice' %}
                        <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 10px;">
                            <span>{{ round_info.question_text }}</span>
                            {% if round_info.is_ai_generated %}
                                <span class="ai-badge" style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">ü§ñ AI</span>
                            {% else %}
                                <span class="db-badge" style="background: #2196F3; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üíæ DB</span>
                            {% endif %}
                        </div>
                        <ul class="multiple-choice-options">
                            {% for choice in round_info.choices %}
                                <li>{{ choice }}</li>
                            {% endfor %}
                        </ul>
                    {% elif round_info.round_type == 'mastermind' %}
                        {% if round_info.state == 'waiting_for_player_selection' %}
                            <div class="mastermind-player-selection">
                                <h3>Select Next Player</h3>
                                <div class="available-players">
                                    {% for player in round_info.available_players %}
                                        <div class="player-option" style="margin: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 10px; display: inline-block; cursor: pointer;" 
                                             onclick="selectMastermindPlayer({{ player.id }}, '{{ player.name }}', '{{ player.specialist_subject }}')">
                                            <strong>{{ player.name }}</strong><br>
                                            <span style="color: #666;">{{ player.specialist_subject }}</span>
                                        </div>
                                    {% endfor %}
                                </div>
                                {% if round_info.all_players %}
                                    <div class="mastermind-player-status" style="margin-top: 20px;">
                                        <h4>All Players Status</h4>
                                        <div class="player-status-grid">
                                            {% for player in round_info.all_players %}
                                                {% if player.id in round_info.completed_players %}
                                                    <div class="player-status-item completed" style="padding: 10px; margin: 5px; border: 1px solid #28a745; border-radius: 5px; background: #d4edda;">
                                                        <span class="player-name">‚úÖ {{ player.name }}</span>
                                                        <span class="player-subject">{{ player.specialist_subject|default:"No Subject" }}</span>
                                                        <span class="player-score">{{ player.current_score|default:0 }} points</span>
                                                    </div>
                                                {% else %}
                                                    <div class="player-status-item waiting" style="padding: 10px; margin: 5px; border: 1px solid #6c757d; border-radius: 5px; background: #f8f9fa;">
                                                        <span class="player-name">‚è≥ {{ player.name }}</span>
                                                        <span class="player-subject">{{ player.specialist_subject|default:"No Subject Set" }}</span>
                                                        <span class="player-status">Waiting</span>
                                                    </div>
                                                {% endif %}
                                            {% endfor %}
                                        </div>
                                    </div>
                                {% elif round_info.completed_players %}
                                    <div style="margin-top: 15px; color: #666;">
                                        <small>Completed players: {{ round_info.completed_players|length }}</small>
                                    </div>
                                {% endif %}
                            </div>
                        {% elif round_info.state == 'asking_ready' %}
                            <div class="mastermind-ready-check">
                                <h3>{{ round_info.current_player.name }}, are you ready?</h3>
                                <p>Subject: <strong>{{ round_info.current_player.specialist_subject }}</strong></p>
                                <div class="ready-controls">
                                    <button class="btn btn-success" onclick="sendReadyResponse(true)">Player is Ready</button>
                                    <button class="btn btn-secondary" onclick="sendReadyResponse(false)">Not Ready</button>
                                </div>
                            </div>
                        {% elif round_info.state == 'playing' %}
                            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 10px;">
                                <span>{{ round_info.question_text }}</span>
                                {% if round_info.is_ai_generated %}
                                    <span class="ai-badge" style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">ü§ñ AI</span>
                                {% else %}
                                    <span class="db-badge" style="background: #2196F3; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üíæ DB</span>
                                {% endif %}
                                <span class="mastermind-badge" style="background: #9C27B0; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üß† {{ round_info.current_player.specialist_subject }}</span>
                            </div>
                            <ul class="multiple-choice-options">
                                {% for choice in round_info.choices %}
                                    <li>{{ choice }}</li>
                                {% endfor %}
                            </ul>
                        {% elif round_info.state == 'player_complete' %}
                            <div class="mastermind-player-complete">
                                <h3>{{ round_info.current_player.name }} has finished!</h3>
                                <p>They completed their specialist round on <strong>{{ round_info.current_player.specialist_subject }}</strong></p>
                                <button class="btn btn-primary" onclick="continueToNextPlayer()">Select Next Player</button>
                            </div>
                        {% elif round_info.phase == 'general' %}
                            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 10px;">
                                <span>{{ round_info.question_text }}</span>
                                {% if round_info.is_ai_generated %}
                                    <span class="ai-badge" style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">ü§ñ AI</span>
                                {% else %}
                                    <span class="db-badge" style="background: #2196F3; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üíæ DB</span>
                                {% endif %}
                                <span class="general-badge" style="background: #FF5722; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üìö General Knowledge</span>
                            </div>
                            <ul class="multiple-choice-options">
                                {% for choice in round_info.choices %}
                                    <li>{{ choice }}</li>
                                {% endfor %}
                            </ul>
                        {% else %}
                            <div class="mastermind-waiting">
                                <h3>üß† Mastermind Round</h3>
                                <p>{{ round_info.message|default:'Preparing mastermind round...' }}</p>
                            </div>
                        {% endif %}
                    {% endif %}
                </div>

                {% if round_info.is_active %}
                    {% if round_info.round_type == 'mastermind' and round_info.state == 'playing' %}
                        <div id="countdown-display" class="countdown">
                            <span id="countdown-timer">{{ config.round_time_seconds }}</span> seconds remaining
                        </div>

                        <button id="end-round-btn" class="btn">
                            ‚èπÔ∏è End Round Early
                        </button>
                    {% elif round_info.round_type != 'mastermind' %}
                        <div id="countdown-display" class="countdown">
                            <span id="countdown-timer">{{ config.round_time_seconds }}</span> seconds remaining
                        </div>

                        <button id="end-round-btn" class="btn">
                            ‚èπÔ∏è End Round Early
                        </button>
                    {% endif %}
                {% else %}
                    <div class="alert alert-success">
                        Round {{ round_info.round_number }} completed!
                    </div>

                    <div id="answers-display" style="display: none;">
                        <h3>Player Answers</h3>
                        <div id="answers-grid" class="answers-grid">
                            <!-- Answers will be populated here -->
                        </div>

                        <div class="text-center" style="margin-top: 20px;">
                            {% if round_info.round_number < config.num_rounds %}
                                <button id="next-round-btn" class="btn btn-success" style="display: none;">
                                    ‚ñ∂Ô∏è Start Next Round
                                </button>
                            {% else %}
                                <button id="show-final-scores-btn" class="btn btn-success" style="display: none;">
                                    üèÜ Show Final Scores
                                </button>
                            {% endif %}
                        </div>
                    </div>
                {% endif %}
            </div>
        {% endwith %}
    {% else %}
        <div class="text-center">
            <h2>Ready to Start!</h2>
            <p>{{ player_count }} players connected</p>
            
            <button id="start-round-btn" class="btn btn-success">
                üöÄ Start Round
            </button>
        </div>
    {% endif %}
</div>

<!-- Removed duplicate buttons - now in pre-game dashboard -->

<style>
/* Removed redundant header styles since we removed the header */

.round-header {
    text-align: center;
    margin-bottom: 15px;
}

.round-header h2 {
    margin: 0 0 10px 0;
    color: #495057;
}

.round-details {
    display: flex;
    justify-content: center;
    gap: 30px;
    font-size: 1.1em;
    color: #6c757d;
}

.category {
    background: #e9ecef;
    padding: 5px 15px;
    border-radius: 20px;
    font-weight: bold;
}

.letter {
    background: #fff3cd;
    padding: 5px 15px;
    border-radius: 20px;
    font-weight: bold;
    color: #856404;
}

.game-prompt {
    font-size: 2.5em;
    font-weight: bold;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 40px 25px;
    border-radius: 15px;
    margin: 15px 0;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    min-height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.countdown {
    font-size: 2em;
    font-weight: bold;
    text-align: center;
    color: #007bff;
    margin: 20px 0;
    background: #f8f9fa;
    border: 2px solid #007bff;
    border-radius: 10px;
    padding: 15px;
    transition: all 0.3s ease;
}

.countdown.timer-warning {
    border-color: #ffc107;
    background-color: #fff3cd;
    color: #856404;
}

.countdown.timer-danger {
    border-color: #dc3545;
    background-color: #f8d7da;
    color: #721c24;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.answers-grid {
    display: grid;
    gap: 6px;
    margin: 10px 0;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    max-width: 100%;
    max-height: 60vh;
    overflow-y: auto;
}

.answer-card {
    background: #f8f9fa;
    border: 2px solid #6c757d;
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.5s ease;
    position: relative;
    font-size: 0.85em;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.answer-card.show {
    opacity: 1;
    transform: translateY(0);
}

.answer-card.unique {
    border-color: #28a745;
    background: #d4edda;
}

.answer-card.valid {
    border-color: #007bff;
    background: #e7f3ff;
}

.answer-card.invalid {
    border-color: #dc3545;
    background: #f8d7da;
}

.player-name {
    font-weight: bold;
    font-size: 0.85em;
    margin-bottom: 3px;
    color: #495057;
}

.player-answer {
    font-size: 1em;
    margin: 4px 0;
    font-weight: bold;
    color: #212529;
    word-wrap: break-word;
    flex-grow: 1;
}

.points {
    font-weight: bold;
    font-size: 0.9em;
    margin: 3px 0;
    color: #6c757d;
}

.points.unique { color: #28a745; }
.points.valid { color: #007bff; }
.points.invalid { color: #dc3545; }

.validation-controls {
    display: flex;
    gap: 5px;
    margin-top: 8px;
    justify-content: center;
}

.validation-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    font-size: 0.8em;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
}

.validation-btn.valid {
    background: #28a745;
    color: white;
}

.validation-btn.invalid {
    background: #dc3545;
    color: white;
}

.validation-btn:hover {
    transform: scale(1.05);
}

.validation-btn.active {
    box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
}

.answers-header {
    text-align: center;
    margin-bottom: 20px;
}

.answers-header h3 {
    margin: 0 0 10px 0;
    color: #495057;
}

.round-info-small {
    font-size: 0.9em;
    color: #6c757d;
    background: #f8f9fa;
    padding: 8px 15px;
    border-radius: 20px;
    display: inline-block;
}
    .multiple-choice-options {
        list-style-type: none;
        padding: 0;
        margin-top: 15px;
        font-size: 0.8em; /* Smaller font for choices */
        font-weight: normal; /* Normal weight for choices */
    }

    .multiple-choice-options li {
        background: rgba(255, 255, 255, 0.2);
        margin-bottom: 5px;
        padding: 8px 15px;
        border-radius: 8px;
    }
    .multiple-choice-options {
        list-style-type: none;
        padding: 0;
        margin-top: 15px;
        font-size: 0.8em; /* Smaller font for choices */
        font-weight: normal; /* Normal weight for choices */
    }

    .multiple-choice-options li {
        background: rgba(255, 255, 255, 0.2);
        margin-bottom: 5px;
        padding: 8px 15px;
        border-radius: 8px;
    }
    
    /* MasterMind Player Status Styling */
    .mastermind-playing-status {
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
        margin: 20px 0;
    }
    
    .current-activity {
        text-align: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    
    .current-activity h2 {
        margin: 0 0 10px 0;
        font-size: 1.8em;
    }
    
    .current-activity p {
        margin: 5px 0;
        font-size: 1.1em;
    }
    
    .mastermind-player-status h3 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 1.4em;
    }
    
    .player-status-item {
        display: grid;
        grid-template-columns: 2fr 2fr 1fr;
        gap: 15px;
        padding: 12px 15px;
        margin-bottom: 8px;
        border-radius: 8px;
        align-items: center;
    }
    
    .player-status-item.active {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    
    .player-status-item.completed {
        background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .player-status-item.waiting {
        background: #e9ecef;
        color: #495057;
        border: 2px dashed #ced4da;
    }
    
    .player-name {
        font-weight: bold;
        font-size: 1.1em;
    }
    
    .player-subject {
        font-style: italic;
        opacity: 0.9;
    }
    
    .player-progress, .player-points, .player-status {
        text-align: right;
        font-weight: 500;
    }
</style>

<script>
let countdownInterval;
let currentAnswers = [];
let answerIndex = 0;
let gameSocket;
let currentRoundType = '{{ round_info.round_type|default:"flower_fruit_veg" }}';
// Handle legacy round types
if (currentRoundType === 'starts_with') {
    currentRoundType = 'flower_fruit_veg';
}
let currentCorrectAnswer = ''; // Will be set when rounds start
let currentRoundNumber = {{ game_session.current_round_number|default:0 }};
let totalRounds = {{ config.num_rounds|default:10 }};
let roundEndedViaWebSocket = false; // Track if WebSocket already handled round end
let autoEndRoundTimeout = null; // Track the auto-end timeout

console.log('üîç DEBUG: Initialized currentRoundType to:', currentRoundType);
console.log('üîç DEBUG: Initialized currentCorrectAnswer to:', currentCorrectAnswer);

// Debug function to check current state
function debugCurrentState() {
    console.log('üîç DEBUG: Current state check:');
    console.log('  - currentRoundType:', currentRoundType);
    console.log('  - currentCorrectAnswer:', currentCorrectAnswer);
    console.log('  - currentAnswers length:', currentAnswers.length);
}

// Call debug every 5 seconds
setInterval(debugCurrentState, 5000);

// Initialize WebSocket connection
function initWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/game/{{ game_session.game_code }}/`;

    gameSocket = new WebSocket(wsUrl);

    gameSocket.onopen = () => {
        // Send identify message with player_id (if present)
        if (window.playerId) {
            gameSocket.send(JSON.stringify({type: 'identify', player_id: window.playerId}));
        }
        console.log('WebSocket connected');
    };

    gameSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        handleWebSocketMessage(data);
    };

    gameSocket.onclose = function(e) {
        console.log('WebSocket disconnected');
        // Attempt to reconnect after 3 seconds
        setTimeout(initWebSocket, 3000);
    };

    gameSocket.onerror = function(e) {
        console.log('WebSocket error:', e);
    };
}

// Handle WebSocket messages
function handleWebSocketMessage(data) {
    console.log('üîç WebSocket message received:', data.type, data);
    switch(data.type) {
        case 'timer_update':
            console.log('üîç Timer update:', data.data.time_remaining);
            updateTimer(data.data.time_remaining);
            break;
        case 'round_started':
            console.log('üîç Round started:', data.data);
            updateRoundDisplay(data.data);
            break;
        case 'round_update':
            console.log('üîç Round update (MasterMind state change):', data.data);
            updateRoundDisplay(data.data);
            break;
        case 'round_ended':
            console.log('üîç Round ended:', data.data);
            handleRoundEnded(data.data);
            break;
        case 'score_update':
            handleScoreUpdate(data.data);
            break;
        case 'mastermind_player_completed':
            console.log('üîç Mastermind player completed:', data.data);
            handleMastermindPlayerCompleted(data.data);
            break;
        case 'mastermind_progress_update':
            console.log('üîç Mastermind progress update:', data.data);
            handleMastermindProgressUpdate(data.data);
            break;
        case 'game_state':
        case 'game_state_sync':
        case 'game_update':
            updateGameState(data.data);
            break;
    }
}

// Update game state (player count, etc.)
function updateGameState(data) {
    // Update player count
    const playerCountElement = document.querySelector('.player-count');
    if (playerCountElement && data.player_count !== undefined) {
        playerCountElement.textContent = `${data.player_count}`;
    }
    
    // Update player list if we have players data and we're in waiting state
    if (data.players && Array.isArray(data.players)) {
        const playerListContent = document.getElementById('player-list-content');
        if (playerListContent) {
            if (data.players.length > 0) {
                playerListContent.innerHTML = data.players.map(player => `
                    <div class="player-item" style="padding: 5px 0; border-bottom: 1px solid #eee;">
                        <strong>${player.name}</strong>
                        <small style="color: #666;"> - Joined ${player.joined_at}</small>
                    </div>
                `).join('');
            } else {
                playerListContent.innerHTML = '<p style="color: #666; font-style: italic;">No players have joined yet.</p>';
            }
        }
        
        // Update start game button visibility
        const startGameBtn = document.getElementById('start-game-btn');
        const waitingBtn = document.getElementById('waiting-for-players-btn');
        if (startGameBtn && waitingBtn) {
            if (data.player_count > 0) {
                startGameBtn.style.display = 'inline-block';
                waitingBtn.style.display = 'none';
            } else {
                startGameBtn.style.display = 'none';
                waitingBtn.style.display = 'inline-block';
            }
        }
    }
    
    console.log('Game state updated:', data);
}

// Handle score update via WebSocket
function handleScoreUpdate(data) {
    // Show a brief notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-weight: bold;
    `;
    notification.textContent = data.message;
    document.body.appendChild(notification);

    // Remove notification after 3 seconds
    setTimeout(() => {
        document.body.removeChild(notification);
    }, 3000);
}

// Handle mastermind player completed via WebSocket
function handleMastermindPlayerCompleted(data) {
    console.log('üîç Mastermind player completed:', data);
    
    // Show completion notification
    showNotification(`${data.player_name} completed their specialist round! ${data.correct_answers}/${data.total_questions} correct (${data.points_earned} points)`, 'success');
    
    // Refresh the round display to show updated player status
    // The server should send a round_update message after this anyway, but we can trigger a refresh
    setTimeout(() => {
        // The round display will be updated via the round_update WebSocket message
        console.log('üîç Player completion processed, waiting for round update...');
    }, 500);
}

// Handle mastermind progress updates during rapid-fire session
function handleMastermindProgressUpdate(data) {
    console.log('üîç Mastermind progress update received:', data);
    
    // Update the current activity display
    const currentActivity = document.querySelector('.current-activity h2');
    console.log('üîç Current activity element found:', !!currentActivity);
    if (currentActivity) {
        currentActivity.textContent = `${data.player_name} is answering rapid-fire questions`;
    }
    
    // Update the progress display
    const progressElement = document.querySelector('.current-activity p:last-child');
    console.log('üîç Progress element found:', !!progressElement);
    console.log('üîç Progress element content before:', progressElement?.textContent);
    
    if (progressElement) {
        progressElement.innerHTML = `Progress: Question ${data.current_question} of ${data.total_questions} | Correct: ${data.correct_answers}`;
        console.log('üîç Progress element content after:', progressElement.textContent);
    }
    
    // Update any existing progress bars or counters in the player status
    const activePlayerProgress = document.querySelector('.player-status-item.active .player-progress');
    console.log('üîç Active player progress element found:', !!activePlayerProgress);
    if (activePlayerProgress) {
        activePlayerProgress.textContent = `Question ${data.current_question}/${data.total_questions}`;
    }
}

// Update timer display
function updateTimer(timeRemaining) {
    const timerElement = document.getElementById('countdown-timer');
    const countdownDisplay = document.getElementById('countdown-display');
    
    if (timerElement) {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        timerElement.textContent = formattedTime;
        
        // Update countdown styling based on time remaining
        if (countdownDisplay) {
            countdownDisplay.classList.remove('timer-warning', 'timer-danger');
            
            if (timeRemaining <= 10) {
                countdownDisplay.classList.add('timer-danger');
                countdownDisplay.innerHTML = `<span id="countdown-timer" style="color: #dc3545; font-weight: bold;">${formattedTime}</span> seconds remaining`;
            } else if (timeRemaining <= 30) {
                countdownDisplay.classList.add('timer-warning');
                countdownDisplay.innerHTML = `<span id="countdown-timer" style="color: #ffc107; font-weight: bold;">${formattedTime}</span> seconds remaining`;
            } else {
                countdownDisplay.innerHTML = `<span id="countdown-timer">${formattedTime}</span> seconds remaining`;
            }
        }

        // Timer reaching zero is handled automatically by the server
        if (timeRemaining <= 0) {
            clearInterval(countdownInterval);
            if (timerElement) {
                timerElement.textContent = "Time's Up!";
            }
            console.log('üîç TIMER: Timer reached zero, waiting for server to end round automatically');
            
            // Fallback: If server doesn't send round_ended within 3 seconds, manually trigger end round
            autoEndRoundTimeout = setTimeout(() => {
                if (!roundEndedViaWebSocket) {
                    console.log('üîç TIMER: Server did not send round_ended message, manually ending round');
                    endRound();
                } else {
                    console.log('üîç TIMER: WebSocket round_ended already received, no manual intervention needed');
                }
                autoEndRoundTimeout = null;
            }, 3000);
        }
    }
}

// Update round display when new round starts via WebSocket
function updateRoundDisplay(data) {
    // Check if data is in current_round or at root level
    const roundData = data.current_round || data;
    
    if (roundData && roundData.round_number) {
        // Reset WebSocket flag for new round and clear any pending timeouts
        roundEndedViaWebSocket = false;
        if (autoEndRoundTimeout) {
            clearTimeout(autoEndRoundTimeout);
            autoEndRoundTimeout = null;
        }
        
        // Clear the correct answer from previous round when new round starts
        const oldCorrectAnswer = currentCorrectAnswer;
        currentCorrectAnswer = '';
        console.log('üîç ROUND START: Cleared currentCorrectAnswer from', oldCorrectAnswer, 'to empty');
        
        // Update global round number and type
        currentRoundNumber = roundData.round_number;
        currentRoundType = roundData.round_type || 'flower_fruit_veg';
        // Handle legacy round types
        if (currentRoundType === 'starts_with') {
            currentRoundType = 'flower_fruit_veg';
        }
        
        // Set new correct answer for multiple choice rounds
        if (currentRoundType === 'multiple_choice' && roundData.correct_answer) {
            currentCorrectAnswer = roundData.correct_answer;
            console.log('üîç ROUND START: Set new currentCorrectAnswer to:', currentCorrectAnswer);
        } else if (currentRoundType === 'multiple_choice') {
            console.log('üîç ROUND START: Multiple choice round but no correct_answer in data:', roundData);
        }
        
        console.log('WebSocket round start - currentRoundType:', currentRoundType, 'currentCorrectAnswer:', currentCorrectAnswer);
        
        console.log('Updating round display:', {
            round_number: roundData.round_number,
            round_type: currentRoundType,
            question_text: roundData.question_text,
            category: roundData.category,
            choices: roundData.choices
        });
        
        // Replace the entire game state content with the active round display
        const gameState = document.getElementById('game-state');
        if (!gameState) {
            console.error('Game state element not found!');
            return;
        }
        
        // Build round details HTML based on round type
        let roundDetailsHtml = '';
        let gamePromptHtml = '';
        
        if (currentRoundType === 'flower_fruit_veg') {
            const categoryName = roundData.category?.name || roundData.category || roundData.category_name || 'Category';
            const letter = roundData.letter || roundData.prompt_letter;
            
            roundDetailsHtml = `
                <span class="category">${categoryName}</span>
                <span class="letter">Letter: ${letter}</span>
            `;
            gamePromptHtml = `${categoryName} that start with ${letter}`;
        } else if (currentRoundType === 'multiple_choice') {
            const category = roundData.category || 'Multiple Choice';
            const questionText = roundData.question_text || roundData.question || 'Question not available';
            const isAIGenerated = roundData.is_ai_generated;
            
            roundDetailsHtml = `<span class="category">${category}</span>`;
            
            let choicesHtml = '';
            if (roundData.choices && Array.isArray(roundData.choices)) {
                choicesHtml = '<ul class="multiple-choice-options">' + 
                    roundData.choices.map(choice => `<li>${choice}</li>`).join('') + 
                    '</ul>';
            } else {
                console.error('No choices available for multiple choice question:', roundData);
            }
            
            // Add AI/DB badge
            const badge = isAIGenerated ? 
                '<span class="ai-badge" style="background: #4CAF50; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">ü§ñ AI</span>' :
                '<span class="db-badge" style="background: #2196F3; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">üíæ DB</span>';
            
            gamePromptHtml = `<div style="display: flex; align-items: center; justify-content: center; margin-bottom: 10px;">
                <span>${questionText}</span>
                ${badge}
            </div>${choicesHtml}`;
        } else if (currentRoundType === 'mastermind') {
            // Handle MasterMind round display
            const state = roundData.state || 'waiting_for_player_selection';
            
            if (state === 'waiting_for_player_selection') {
                roundDetailsHtml = `<span class="category">üß† Mastermind</span>`;
                gamePromptHtml = `<div class="mastermind-player-selection">
                    <h3>Select Next Player</h3>
                    <div class="available-players">
                        ${(roundData.available_players || []).map(player => `
                            <div class="player-option" style="margin: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 10px; display: inline-block; cursor: pointer;" 
                                 onclick="selectMastermindPlayer(${player.id}, '${player.name}', '${player.specialist_subject}')">
                                <strong>${player.name}</strong><br>
                                <span style="color: #666;">${player.specialist_subject}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            } else if (state === 'asking_ready') {
                const currentPlayer = roundData.current_player;
                roundDetailsHtml = `<span class="category">üß† Mastermind - Ready Check</span>`;
                gamePromptHtml = `<div class="mastermind-ready-check">
                    <h3>${currentPlayer.name}, are you ready?</h3>
                    <p>Subject: <strong>${currentPlayer.specialist_subject}</strong></p>
                    <div class="ready-controls">
                        <button class="btn btn-success" onclick="sendReadyResponse(true)">Player is Ready</button>
                        <button class="btn btn-secondary" onclick="sendReadyResponse(false)">Not Ready</button>
                    </div>
                </div>`;
            } else if (state === 'playing') {
                const currentPlayer = roundData.current_player;
                const questionIndex = roundData.current_question_index || 1;
                const totalQuestions = roundData.questions_per_player || 25;
                const completedPlayers = roundData.completed_players || [];
                const availablePlayers = roundData.available_players || [];
                
                roundDetailsHtml = `<span class="category">üß† ${currentPlayer?.name} is completing their Specialist Subject Round</span>`;
                
                // Build player status list
                let playerStatusHtml = '<div class="mastermind-player-status">';
                playerStatusHtml += '<h3>Player Status</h3>';
                
                // Current player (actively playing)
                playerStatusHtml += `<div class="player-status-item active">
                    <span class="player-name">üéØ ${currentPlayer?.name}</span>
                    <span class="player-subject">${currentPlayer?.specialist_subject}</span>
                    <span class="player-progress">Question ${questionIndex}/${totalQuestions}</span>
                </div>`;
                
                // Completed players
                completedPlayers.forEach(player => {
                    const points = player.points || 0;
                    playerStatusHtml += `<div class="player-status-item completed">
                        <span class="player-name">‚úÖ ${player.name}</span>
                        <span class="player-subject">${player.specialist_subject}</span>
                        <span class="player-points">${points} points</span>
                    </div>`;
                });
                
                // Show all connected players, indicating their mastermind status
                // Use all_players from round data (includes all connected players)
                const allPlayers = roundData.all_players || [];
                
                if (allPlayers && Array.isArray(allPlayers)) {
                    allPlayers.forEach(player => {
                        // Skip if this is the current player (already shown above)
                        if (player.id === currentPlayer?.id) {
                            return;
                        }
                        
                        // Check if player has completed their mastermind round
                        const isCompleted = completedPlayers.find(p => p.id === player.id);
                        if (isCompleted) {
                            // Already shown in completed players section above
                            return;
                        }
                        
                        // Show as waiting player
                        const specialistSubject = player.specialist_subject || 'No Subject Set';
                        playerStatusHtml += `<div class="player-status-item waiting">
                            <span class="player-name">‚è≥ ${player.name}</span>
                            <span class="player-subject">${specialistSubject}</span>
                            <span class="player-status">Waiting</span>
                        </div>`;
                    });
                } else {
                    // Fallback to available players if all_players not available
                    availablePlayers.forEach(player => {
                        if (player.id !== currentPlayer?.id && !completedPlayers.find(p => p.id === player.id)) {
                            playerStatusHtml += `<div class="player-status-item waiting">
                                <span class="player-name">‚è≥ ${player.name}</span>
                                <span class="player-subject">${player.specialist_subject || 'No Subject'}</span>
                                <span class="player-status">Waiting</span>
                            </div>`;
                        }
                    });
                }
                
                playerStatusHtml += '</div>';
                
                gamePromptHtml = `<div class="mastermind-playing-status">
                    <div class="current-activity">
                        <h2>${currentPlayer?.name} is answering rapid-fire questions</h2>
                        <p>Subject: <strong>${currentPlayer?.specialist_subject}</strong></p>
                        <p>Progress: Question ${questionIndex} of ${totalQuestions}</p>
                    </div>
                    ${playerStatusHtml}
                </div>`;
            } else if (state === 'player_complete') {
                const currentPlayer = roundData.current_player;
                roundDetailsHtml = `<span class="category">üß† Mastermind Complete</span>`;
                gamePromptHtml = `<div class="mastermind-player-complete">
                    <h3>${currentPlayer?.name} has finished!</h3>
                    <p>They completed their specialist round on <strong>${currentPlayer?.specialist_subject}</strong></p>
                    <button class="btn btn-primary" onclick="continueToNextPlayer()">Select Next Player</button>
                </div>`;
            } else {
                roundDetailsHtml = `<span class="category">üß† Mastermind</span>`;
                gamePromptHtml = `<div>Preparing mastermind round...</div>`;
            }
        }
        
        // Replace the game state content with active round HTML
        // Use 90 seconds for MasterMind playing state, otherwise use default
        let initialTime = roundData.time_remaining || roundData.total_time || 30;
        if (currentRoundType === 'mastermind' && roundData.state === 'playing') {
            initialTime = roundData.time_remaining || 90; // 90 seconds for MasterMind specialist questions
        }
        const minutes = Math.floor(initialTime / 60);
        const seconds = initialTime % 60;
        const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Hide timer and end round button for MasterMind rounds (players manage their own 90s timer)
        const showTimer = currentRoundType !== 'mastermind';
        
        const timerHtml = showTimer ? `
            <div id="countdown-display" class="countdown">
                <span id="countdown-timer">${formattedTime}</span> seconds remaining
            </div>
            <button id="end-round-btn" class="btn">‚èπÔ∏è End Round Early</button>
        ` : '';
        
        gameState.innerHTML = `
            <div id="round-display">
                <div class="round-header">
                    <div class="round-title">
                        <h2>Round ${roundData.round_number} of {{ config.num_rounds }}</h2>
                        <span class="player-count">{{ player_count }} players</span>
                    </div>
                    <div class="round-details">
                        ${roundDetailsHtml}
                    </div>
                </div>
                <div class="game-prompt">
                    ${gamePromptHtml}
                </div>
                ${timerHtml}
            </div>
        `;
        
        // Re-attach event listener to the new end round button
        const newEndRoundBtn = document.getElementById('end-round-btn');
        if (newEndRoundBtn) {
            newEndRoundBtn.addEventListener('click', endRound);
        }
        
        console.log('üîç ROUND START: Replaced game state content with active round display');
    }

    // Hide answers display if it exists 
    const answersDisplay = document.getElementById('answers-display');
    if (answersDisplay) {
        answersDisplay.style.display = 'none';
        console.log('üîç NEW ROUND: Hidden answers display, preserving element');
    }
}

// Handle round ended via WebSocket
function handleRoundEnded(data) {
    console.log('üîç WEBSOCKET: handleRoundEnded called with data:', data);
    
    // Mark that WebSocket handled the round end and clear fallback timeout
    roundEndedViaWebSocket = true;
    if (autoEndRoundTimeout) {
        clearTimeout(autoEndRoundTimeout);
        autoEndRoundTimeout = null;
        console.log('üîç WEBSOCKET: Cleared auto-end timeout since WebSocket handled round end');
    }
    
    // Always handle round end, even if no answers
    currentAnswers = data.answers || [];
    console.log('üîç WEBSOCKET: Round ended, received', currentAnswers.length, 'answers:', currentAnswers.map(a => `${a.player_name}: ${a.answer_text}`));
    
    // Update round type from WebSocket data if available
    if (data.round_type) {
        currentRoundType = data.round_type;
    }
    
    // Store correct answer for multiple choice questions
    if (data.correct_answer) {
        currentCorrectAnswer = data.correct_answer;
        console.log('üîç ROUND ENDED: Updated currentCorrectAnswer to:', currentCorrectAnswer);
    } else {
        console.log('üîç ROUND ENDED: No correct_answer in data:', data);
    }

    // Hide round controls
    const countdownDisplay = document.getElementById('countdown-display');
    const endRoundBtn = document.getElementById('end-round-btn');
    if (countdownDisplay) countdownDisplay.style.display = 'none';
    if (endRoundBtn) endRoundBtn.style.display = 'none';

    // Show round completed message
    const gamePrompt = document.querySelector('.game-prompt');
    if (gamePrompt) {
        if (currentAnswers.length > 0) {
            gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>Collecting answers...</small>`;
        } else {
            gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>No answers submitted</small>`;
        }
    }

    // Automatically show answers after a brief delay
    setTimeout(() => {
        if (gamePrompt) {
            if (currentAnswers.length > 0) {
                gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>Reviewing answers...</small>`;
            } else {
                gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>No answers to review</small>`;
            }
        }
        showAnswers();
    }, 1500);
}

// Start countdown timer (now synchronized with server)
function startCountdown(seconds) {
    // Timer will be updated by updateGameState function
    // which gets accurate time remaining from server
    console.log('Timer will be synchronized with server');
}

// Start game (from waiting state)
document.getElementById('start-game-btn')?.addEventListener('click', function() {
    fetch('{% url "game_sessions:start_game" game_session.game_code %}', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            console.log('Game started successfully');
            // Page will be updated via WebSocket, or reload to get active template
            window.location.reload();
        } else {
            console.log('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.log('Error starting game: ' + error);
    });
});

// Start round (works for first round and subsequent rounds)
document.getElementById('start-round-btn')?.addEventListener('click', function() {
    startRound();
});

// Start next round
document.getElementById('next-round-btn')?.addEventListener('click', function() {
    startRound();
});

// Start round function
function startRound() {
    fetch('{% url "game_sessions:start_round" game_session.game_code %}', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Don't overwrite currentCorrectAnswer here - WebSocket already set it correctly
            // The AJAX response might have stale data, so trust the WebSocket
            console.log('startRound success - keeping WebSocket answer:', currentCorrectAnswer);
            console.log('startRound AJAX response had answer:', data.correct_answer);
            // WebSocket will handle the round update, no need to reload
            console.log('Round started successfully');
        } else if (data.status === 'game_complete') {
            // Game is finished, show final scores
            showFinalScores(data.final_scores);
        } else {
            console.log('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.log('Error starting round: ' + error);
    });
}

// Show final scores when game is complete
function showFinalScores(scores) {
    // Define color scheme for different ranks
    const rankColors = [
        '#FFD700', // Gold - 1st place
        '#C0C0C0', // Silver - 2nd place  
        '#CD7F32', // Bronze - 3rd place
        '#228B22', // Green - 4th place
        '#FFA500', // Orange - 5th place
        '#FF4500', // Red-Orange - 6th place
        '#DC143C', // Crimson - 7th place
        '#8B4513', // Saddle Brown - 8th place
        '#4B0082', // Indigo - 9th place
        '#2F4F4F', // Dark Slate Gray - 10th place
        '#696969', // Dim Gray - 11th place
        '#000000'  // Black - 12th+ place
    ];
    
    // Group players by rank with tie handling
    const rankGroups = [];
    let currentRank = 1;
    let currentGroup = [];
    
    for (let i = 0; i < scores.length; i++) {
        const score = scores[i];
        
        // Check if this player is tied with previous players
        if (i > 0 && scores[i].total_score !== scores[i-1].total_score) {
            // Not tied - finalize current group and start new one
            if (currentGroup.length > 0) {
                rankGroups.push({
                    rank: currentRank,
                    players: currentGroup,
                    color: rankColors[Math.min(currentRank - 1, rankColors.length - 1)]
                });
            }
            currentRank = i + 1;
            currentGroup = [];
        }
        
        currentGroup.push(score);
    }
    
    // Add the last group
    if (currentGroup.length > 0) {
        rankGroups.push({
            rank: currentRank,
            players: currentGroup,
            color: rankColors[Math.min(currentRank - 1, rankColors.length - 1)]
        });
    }
    
    const gameState = document.getElementById('game-state');
    gameState.innerHTML = `
        <div class="text-center">
            <h2>üéâ Game Complete! üéâ</h2>
            <h3>Final Scores</h3>
            <div class="final-scores">
                ${rankGroups.map((group) => `
                    <div class="rank-group">
                        <div class="rank-header" style="background-color: ${group.color}; color: ${group.color === '#FFD700' || group.color === '#FFA500' ? '#000' : '#fff'};">
                            <span class="rank-number">${group.rank}</span>
                            <span class="rank-suffix">${getRankSuffix(group.rank)}</span>
                            ${group.rank === 1 ? '<span class="crown">üëë</span>' : ''}
                        </div>
                        <div class="players-row">
                            ${group.players.map((player) => `
                                <div class="player-card" style="border-color: ${group.color};">
                                    <div class="player-name">${player.player_name}</div>
                                    <div class="player-score">${player.total_score} points</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
            </div>
            <div style="margin-top: 30px;">
                <button id="restart-game-btn" class="btn btn-primary">
                    üîÑ Start New Game
                </button>
            </div>
        </div>
    `;
    
    // Helper function to get rank suffix
    function getRankSuffix(rank) {
        if (rank % 10 === 1 && rank % 100 !== 11) return 'st';
        if (rank % 10 === 2 && rank % 100 !== 12) return 'nd';
        if (rank % 10 === 3 && rank % 100 !== 13) return 'rd';
        return 'th';
    }

    // Add styles for final scores
    const style = document.createElement('style');
    style.textContent = `
        .final-scores {
            max-width: 800px;
            margin: 20px auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .rank-group {
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .rank-header {
            padding: 15px;
            font-size: 1.3em;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .rank-number {
            font-size: 1.8em;
            font-weight: bold;
        }
        .rank-suffix {
            font-size: 0.8em;
            vertical-align: super;
        }
        .players-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
            justify-content: center;
        }
        .player-card {
            background: white;
            border: 3px solid;
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        .player-card:hover {
            transform: translateY(-2px);
        }
        .player-card .player-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        .player-card .player-score {
            font-size: 1.0em;
            color: #28a745;
            font-weight: bold;
        }
        .crown {
            font-size: 1.5em;
            margin-left: 10px;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 600px) {
            .final-scores {
                max-width: 95%;
                padding: 15px;
            }
            .players-row {
                padding: 15px;
            }
            .player-card {
                min-width: 120px;
                padding: 10px;
            }
        }
    `;
    document.head.appendChild(style);

    // Re-attach restart game event listener
    document.getElementById('restart-game-btn').addEventListener('click', function() {
        fetch('{% url "game_sessions:restart_game" game_session.game_code %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Add small delay to ensure restart is fully processed
                setTimeout(() => {
                    window.location.href = '{% url "game_sessions:game_master" game_session.game_code %}';
                }, 500);
            } else {
                console.log('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.log('Error restarting game: ' + error);
        });
    });
}

// End round
document.getElementById('end-round-btn')?.addEventListener('click', function() {
    endRound();
});

function endRound() {
    clearInterval(countdownInterval);

    fetch('{% url "game_sessions:end_round" game_session.game_code %}', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Only update if WebSocket hasn't already handled it
            if (!roundEndedViaWebSocket) {
                currentAnswers = data.answers;
                console.log('üîç AJAX: Round ended, received', currentAnswers.length, 'answers:', currentAnswers.map(a => a.player_name));
                currentRoundType = data.round_type || 'flower_fruit_veg'; // Update round type from response
                // Handle legacy round types
                if (currentRoundType === 'starts_with') {
                    currentRoundType = 'flower_fruit_veg';
                }
                
                // Store correct answer for multiple choice questions
                if (data.correct_answer) {
                    currentCorrectAnswer = data.correct_answer;
                }
            } else {
                console.log('üîç AJAX: Skipping data update - WebSocket already handled round end');
            }

            // Hide round controls
            const countdownDisplay = document.getElementById('countdown-display');
            const endRoundBtn = document.getElementById('end-round-btn');
            if (countdownDisplay) countdownDisplay.style.display = 'none';
            if (endRoundBtn) endRoundBtn.style.display = 'none';

            // Show round completed message
            const gamePrompt = document.querySelector('.game-prompt');
            if (gamePrompt) {
                gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>Collecting answers...</small>`;
            }

            // Automatically show answers after a brief delay
            setTimeout(() => {
                if (gamePrompt) {
                    gamePrompt.innerHTML = `Round ${data.round_number} Complete!<br><small>Reviewing answers...</small>`;
                }
                showAnswers();
            }, 1500);
        } else {
            console.log('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.log('Error ending round: ' + error);
    });
}

// Show answers
// Show answers button removed - answers now show automatically

let showAnswersInProgress = false;

function showAnswers() {
    // Prevent multiple simultaneous calls
    if (showAnswersInProgress) {
        console.log('üîç DEBUG: showAnswers() already in progress, skipping duplicate call');
        return;
    }
    showAnswersInProgress = true;
    
    // Show answers button no longer exists - answers show automatically
    
    // Ensure we have the correct round type - get it from the current round info if not set
    if (!currentRoundType) {
        {% if game_session.current_round_number > 0 %}
            {% with round_info=game_session.get_current_round_info %}
                currentRoundType = '{{ round_info.round_type }}';
                // Handle legacy round types
                if (currentRoundType === 'flower_fruit_veg') {
                    currentRoundType = 'flower_fruit_veg';
                }
            {% endwith %}
        {% endif %}
    }
    
    console.log('üîç DEBUG: showAnswers() called - currentRoundType:', currentRoundType, 'currentAnswers.length:', currentAnswers.length);

    // Create or show answers display area
    let answersDisplay = document.getElementById('answers-display');
    if (!answersDisplay) {
        // Create the answers display area dynamically
        const gameState = document.getElementById('game-state');
        if (!gameState) {
            console.error('üîç ERROR: game-state element not found!');
            return;
        }
        answersDisplay = document.createElement('div');
        answersDisplay.id = 'answers-display';
        gameState.appendChild(answersDisplay);
        console.log('üîç SHOW ANSWERS: Created new answers-display element');
    } else {
        console.log('üîç SHOW ANSWERS: Found existing answers-display element');
    }
    
    // Now populate the content (after element is in DOM)
    const gamePrompt = document.querySelector('.game-prompt');
    const roundInfo = gamePrompt ? gamePrompt.textContent : '';

    // Verify element is in the DOM before setting innerHTML
    if (!answersDisplay.parentNode) {
        console.error('üîç ERROR: answers-display element not attached to DOM! Re-creating...');
        const gameState = document.getElementById('game-state');
        if (gameState) {
            gameState.appendChild(answersDisplay);
        } else {
            console.error('üîç ERROR: Cannot find game-state element to attach answers-display!');
            return;
        }
    }

    // Build correct answer display for multiple choice
    console.log('üîç SHOW ANSWERS: currentRoundType:', currentRoundType, 'currentCorrectAnswer:', currentCorrectAnswer);
    const correctAnswerHtml = (currentRoundType === 'multiple_choice' && currentCorrectAnswer) ? 
        `<div class="correct-answer-display" style="background: #d4edda; border: 2px solid #28a745; padding: 15px; border-radius: 10px; margin: 10px 0; text-align: center;">
            <strong>‚úÖ Correct Answer: ${currentCorrectAnswer}</strong>
        </div>` : '';
    console.log('üîç SHOW ANSWERS: Generated correctAnswerHtml:', correctAnswerHtml);

    // Determine button text based on whether it's the final round
    const isLastRound = currentRoundNumber >= totalRounds;
    const nextButtonText = isLastRound ? 'üèÜ Finish Game' : '‚ñ∂Ô∏è Start Next Round';
    console.log('üîç BUTTON: currentRoundNumber:', currentRoundNumber, 'totalRounds:', totalRounds, 'isLastRound:', isLastRound, 'buttonText:', nextButtonText);
    
    // Safe innerHTML assignment with error handling
    try {
        answersDisplay.innerHTML = `
            <div class="answers-header">
                <h3>Player Answers</h3>
                <div class="round-info-small">${roundInfo}</div>
                ${correctAnswerHtml}
            </div>
            <div id="answers-grid" class="answers-grid"></div>
            <div class="text-center" style="margin-top: 20px;">
                <button id="next-round-btn" class="btn btn-success" style="display: none;">
                    ${nextButtonText}
                </button>
            </div>
        `;
        answersDisplay.style.display = 'block';
        console.log('üîç SHOW ANSWERS: Successfully set innerHTML and made visible');
    } catch (error) {
        console.error('üîç ERROR: Failed to set innerHTML on answers-display:', error);
        return;
    }

    const grid = document.getElementById('answers-grid');
    
    // Clear existing answers
    grid.innerHTML = '';

    // Check if we need to fetch answers from server (e.g., after page refresh)
    if (currentAnswers.length === 0) {
        // Try to fetch answers from server for the current round
        fetch(`/game/{{ game_session.game_code }}/round-answers/`, {
            method: 'GET',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success' && data.answers && data.answers.length > 0) {
                currentAnswers = data.answers;
                // Update round type from fetched data
                if (data.round_type) {
                    currentRoundType = data.round_type;
                    console.log('üîç DEBUG: Updated currentRoundType from server:', currentRoundType);
                }
                // Update correct answer from fetched data
                if (data.correct_answer) {
                    currentCorrectAnswer = data.correct_answer;
                    console.log('üîç AJAX: Updated currentCorrectAnswer from server to:', currentCorrectAnswer);
                } else {
                    console.log('üîç AJAX: No correct_answer in server response:', data);
                }
                // Reset flag and re-call showAnswers now that we have the data
                showAnswersInProgress = false;
                showAnswers();
                return;
            } else {
                // No answers found on server, show no answers message
                // Update round type from fetched data even if no answers
                if (data.round_type) {
                    currentRoundType = data.round_type;
                }
                // Update correct answer from fetched data even if no answers
                if (data.correct_answer) {
                    currentCorrectAnswer = data.correct_answer;
                }
                showNoAnswersMessage();
            }
        })
        .catch(error => {
            console.log('Error fetching answers:', error);
            showNoAnswersMessage();
        })
        .finally(() => {
            // Reset flag regardless of success or failure
            showAnswersInProgress = false;
        });
        return;
    }

    // Check if there are any answers
    const playerCount = currentAnswers.length;
    
    if (playerCount === 0) {
        showNoAnswersMessage();
        showAnswersInProgress = false;
        return;
    }

    // Continue with normal answer display...
    // Add a small delay to ensure DOM is fully ready
    setTimeout(() => {
        displayAnswersGrid();
        // Reset the flag after completion
        showAnswersInProgress = false;
    }, 100);
}

function showNoAnswersMessage() {
    const grid = document.getElementById('answers-grid');
    if (!grid) {
        console.error('üîç ERROR: answers-grid element not found in showNoAnswersMessage()!');
        return;
    }
        // Show "no answers" message
        grid.innerHTML = `
            <div class="no-answers-message" style="
                grid-column: 1 / -1;
                text-align: center;
                padding: 40px;
                color: #666;
                font-size: 1.2em;
                background: #f8f9fa;
                border: 2px dashed #dee2e6;
                border-radius: 10px;
                margin: 20px 0;
            ">
                <div style="font-size: 3em; margin-bottom: 10px;">üòî</div>
                <div>No players submitted answers for this round</div>
                <div style="font-size: 0.9em; margin-top: 10px; color: #999;">
                    Continue to the next round when ready
                </div>
            </div>
        `;
        
        // Show the start next round button immediately and ensure it exists
        let nextRoundBtn = document.getElementById('next-round-btn');
        if (!nextRoundBtn) {
            // Create button if it doesn't exist
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'text-center';
            buttonContainer.style.marginTop = '20px';
            const isLastRound = currentRoundNumber >= totalRounds;
            const nextButtonText = isLastRound ? 'üèÜ Finish Game' : '‚ñ∂Ô∏è Start Next Round';
            buttonContainer.innerHTML = `<button id="next-round-btn" class="btn btn-success">${nextButtonText}</button>`;
            answersDisplay.appendChild(buttonContainer);
            nextRoundBtn = document.getElementById('next-round-btn');
        }
        
        if (nextRoundBtn) {
            // Update button text for final round
            const isLastRound = currentRoundNumber >= totalRounds;
            const nextButtonText = isLastRound ? 'üèÜ Finish Game' : '‚ñ∂Ô∏è Start Next Round';
            nextRoundBtn.textContent = nextButtonText;
            
            nextRoundBtn.style.display = 'inline-block';
            // Remove any existing event listeners and add new one
            const newBtn = nextRoundBtn.cloneNode(true);
            nextRoundBtn.parentNode.replaceChild(newBtn, nextRoundBtn);
            newBtn.addEventListener('click', function() {
                console.log('Next round button clicked (no answers)');
                startRound();
            });
        }
}

function displayAnswersGrid() {
    const grid = document.getElementById('answers-grid');
    if (!grid) {
        console.error('üîç ERROR: answers-grid element not found! Cannot display answers.');
        return;
    }
    
    // Completely clear the grid to prevent duplicates
    grid.innerHTML = '';
    console.log('üîç GRID: Cleared grid before displaying answers');
    
    // Deduplicate answers by player name (keep the first occurrence)
    console.log('üîç DEDUP: Before deduplication:', currentAnswers.map(a => `${a.player_name}: ${a.answer_text}`));
    const seenPlayers = new Set();
    const deduplicatedAnswers = currentAnswers.filter((answer, index) => {
        const key = answer.player_name;
        if (seenPlayers.has(key)) {
            console.warn('üîç WARNING: Duplicate answer found for player:', key, 'at index', index, 'answer:', answer.answer_text, '- removing duplicate');
            return false;
        }
        seenPlayers.add(key);
        return true;
    });
    
    // Use deduplicated answers for display
    currentAnswers = deduplicatedAnswers;
    console.log('üîç DEDUP: After deduplication:', currentAnswers.map(a => `${a.player_name}: ${a.answer_text}`));
    
    const playerCount = currentAnswers.length;
    console.log('üîç DISPLAY GRID: Found grid element, playerCount:', playerCount, 'after deduplication');
    
    // Responsive grid layout optimized for different player counts on 1366x768 screen
    if (playerCount <= 2) {
        grid.style.gridTemplateColumns = `repeat(${playerCount}, 1fr)`;
    } else if (playerCount <= 4) {
        grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    } else if (playerCount <= 6) {
        grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
    } else if (playerCount <= 8) {
        grid.style.gridTemplateColumns = 'repeat(4, 1fr)';
    } else if (playerCount <= 12) {
        grid.style.gridTemplateColumns = 'repeat(4, 1fr)';
    } else if (playerCount <= 16) {
        grid.style.gridTemplateColumns = 'repeat(5, 1fr)';
    } else {
        grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
    }

    // Show answers one by one
    answerIndex = 0;
    showNextAnswer();
}

function showNextAnswer() {
    if (answerIndex >= currentAnswers.length) {
        // All answers shown, show next round button
        const nextRoundBtn = document.getElementById('next-round-btn');
        if (nextRoundBtn) {
            setTimeout(() => {
                // Update button text for final round
                const isLastRound = currentRoundNumber >= totalRounds;
                const nextButtonText = isLastRound ? 'üèÜ Finish Game' : '‚ñ∂Ô∏è Start Next Round';
                nextRoundBtn.textContent = nextButtonText;
                
                nextRoundBtn.style.display = 'inline-block';
                // Remove any existing event listeners and add new one
                const newBtn = nextRoundBtn.cloneNode(true);
                nextRoundBtn.parentNode.replaceChild(newBtn, nextRoundBtn);
                newBtn.addEventListener('click', function() {
                    console.log('Next round button clicked');
                    startRound();
                });
            }, 500);
        }
        return;
    }

    const answer = currentAnswers[answerIndex];
    const grid = document.getElementById('answers-grid');
    
    if (!grid) {
        console.error('üîç ERROR: answers-grid element not found in showNextAnswer()! Stopping answer display.');
        return;
    }

    const answerCard = document.createElement('div');
    
    // For flower_fruit_veg rounds, show all answers as neutral until manually validated
    // For other rounds, use automatic scoring to determine appearance
    let cardClass = 'answer-card';
    if (currentRoundType === 'flower_fruit_veg') {
        cardClass = 'answer-card'; // Neutral styling - no validation indicator
    } else {
        cardClass = `answer-card ${answer.is_unique ? 'unique' : (answer.is_valid ? 'valid' : 'invalid')}`;
    }
    answerCard.className = cardClass;
    answerCard.dataset.answerId = answerIndex;

    // Only show validation controls for "flower_fruit_veg" rounds (use global variable)
    console.log('üîç DEBUG: Showing answer for player:', answer.player_name, 'currentRoundType:', currentRoundType, 'Should show validation?', currentRoundType === 'flower_fruit_veg');
    const validationControlsHtml = currentRoundType === 'flower_fruit_veg' ? `
        <div class="validation-controls">
            <button class="validation-btn valid ${answer.is_valid && !answer.is_unique ? 'active' : ''}"
                    onclick="validateAnswer(${answerIndex}, true)">
                ‚úì Valid
            </button>
            <button class="validation-btn invalid ${!answer.is_valid ? 'active' : ''}"
                    onclick="validateAnswer(${answerIndex}, false)">
                ‚úó Invalid
            </button>
        </div>
    ` : '';

    // For flower_fruit_veg rounds, show neutral points styling until manually validated
    let pointsClass = 'points';
    if (currentRoundType === 'flower_fruit_veg') {
        pointsClass = 'points'; // Neutral styling
    } else {
        pointsClass = `points ${answer.is_unique ? 'unique' : (answer.is_valid ? 'valid' : 'invalid')}`;
    }
    
    answerCard.innerHTML = `
        <div class="player-name">${answer.player_name}</div>
        <div class="player-answer">${answer.answer || answer.answer_text || 'No answer'}</div>
        <div class="${pointsClass}">
            +${answer.points_awarded} points
        </div>
        ${validationControlsHtml}
    `;

    grid.appendChild(answerCard);

    // Animate in
    setTimeout(() => {
        answerCard.classList.add('show');
    }, 100);

    answerIndex++;

    // Show next answer after delay
    setTimeout(() => {
        showNextAnswer();
    }, 1000);
}

// Validate answer function
function validateAnswer(answerIndex, isValid) {
    console.log('üîç VALIDATE: Validating answer at index', answerIndex, 'as', isValid ? 'valid' : 'invalid');
    console.log('üîç VALIDATE: currentAnswers length:', currentAnswers.length);
    
    if (answerIndex >= currentAnswers.length) {
        console.error('üîç VALIDATE: Invalid answerIndex', answerIndex, 'for array length', currentAnswers.length);
        return;
    }

    const answer = currentAnswers[answerIndex];
    const answerCard = document.querySelector(`[data-answer-id="${answerIndex}"]`);
    
    console.log('üîç VALIDATE: Found answer:', answer.player_name, '-', answer.answer_text);
    console.log('üîç VALIDATE: Found answerCard:', answerCard ? 'yes' : 'no');

    // Update the answer data
    answer.is_valid = isValid;
    answer.is_unique = false; // Reset unique status when manually validating

    // Recalculate points based on uniqueness
    if (isValid) {
        // Check if this answer is unique (no other player has the same answer)
        const answerText = answer.answer_text || answer.answer;
        const sameAnswers = currentAnswers.filter(a => {
            const otherAnswerText = a.answer_text || a.answer;
            return otherAnswerText.toLowerCase().trim() === answerText.toLowerCase().trim();
        });

        if (sameAnswers.length === 1) {
            answer.points_awarded = 10; // Unique answer points
            answer.is_unique = true;
        } else {
            answer.points_awarded = 5; // Valid but not unique answer points
            answer.is_unique = false;

            // Update all other answers with the same text to also be non-unique
            sameAnswers.forEach(sameAnswer => {
                if (sameAnswer !== answer) {
                    sameAnswer.points_awarded = 5;
                    sameAnswer.is_unique = false;
                }
            });
        }
    } else {
        answer.points_awarded = 0; // Invalid answer points
        answer.is_unique = false;
    }

    // Update the card appearance
    answerCard.className = `answer-card ${isValid ? 'valid' : 'invalid'} show`;

    // Update points display
    const pointsElement = answerCard.querySelector('.points');
    pointsElement.textContent = `+${answer.points_awarded} points`;
    pointsElement.className = `points ${answer.is_unique ? 'unique' : (isValid ? 'valid' : 'invalid')}`;

    // Update button states (only if validation buttons exist)
    const validBtn = answerCard.querySelector('.validation-btn.valid');
    const invalidBtn = answerCard.querySelector('.validation-btn.invalid');

    if (validBtn && invalidBtn) {
        validBtn.classList.toggle('active', isValid);
        invalidBtn.classList.toggle('active', !isValid);
    }

    // Auto-validate identical answers and recalculate all points
    const currentAnswerText = (answer.answer_text || answer.answer).toLowerCase().trim();

    // First, update all identical answers
    currentAnswers.forEach((otherAnswer, otherIndex) => {
        const otherAnswerText = (otherAnswer.answer_text || otherAnswer.answer).toLowerCase().trim();
        if (otherIndex !== answerIndex && otherAnswerText === currentAnswerText) {

            // Update the other answer with same validation
            otherAnswer.is_valid = isValid;
            otherAnswer.is_unique = answer.is_unique;
            otherAnswer.points_awarded = answer.points_awarded;

            // Update the other answer's display
            const otherCard = document.querySelector(`[data-answer-id="${otherIndex}"]`);
            if (otherCard) {
                otherCard.className = `answer-card ${isValid ? 'valid' : 'invalid'} show`;

                const otherPointsElement = otherCard.querySelector('.points');
                otherPointsElement.textContent = `+${otherAnswer.points_awarded} points`;
                otherPointsElement.className = `points ${otherAnswer.is_unique ? 'unique' : (isValid ? 'valid' : 'invalid')}`;

                const otherValidBtn = otherCard.querySelector('.validation-btn.valid');
                const otherInvalidBtn = otherCard.querySelector('.validation-btn.invalid');
                
                // Only update buttons if they exist (for flower_fruit_veg rounds)
                if (otherValidBtn && otherInvalidBtn) {

                    otherValidBtn.classList.toggle('active', isValid);
                    otherInvalidBtn.classList.toggle('active', !isValid);
                }

                // Send validation to server for the duplicate answer
                fetch('{% url "game_sessions:validate_answer" game_session.game_code %}', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        player_name: otherAnswer.player_name,
                        answer: otherAnswer.answer_text || otherAnswer.answer,
                        is_valid: isValid,
                        points_awarded: otherAnswer.points_awarded
                    })
                });
            }
        }
    });

    // Send validation to server to update database
    fetch('{% url "game_sessions:validate_answer" game_session.game_code %}', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            player_name: answer.player_name,
            answer: answer.answer_text || answer.answer,
            is_valid: isValid,
            points_awarded: answer.points_awarded
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            console.log(`Answer "${answer.answer}" by ${answer.player_name} marked as ${isValid ? 'valid' : 'invalid'}`);
        } else {
            console.log('Error validating answer:', data.error);
        }
    })
    .catch(error => {
        console.log('Error sending validation:', error);
    });
}

// Restart game
document.getElementById('restart-game-btn')?.addEventListener('click', function() {
    fetch('{% url "game_sessions:restart_game" game_session.game_code %}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}',
                'Content-Type': 'application/json',
            },
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Add small delay to ensure restart is fully processed
                setTimeout(() => {
                    window.location.href = '{% url "game_sessions:game_master" game_session.game_code %}';
                }, 500);
            } else {
                console.log('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.log('Error restarting game: ' + error);
        });
});

// Mastermind GM Control Functions
function selectMastermindPlayer(playerId, playerName, specialistSubject) {
    console.log('Selecting mastermind player:', playerId, playerName, specialistSubject);
    
    if (gameSocket && gameSocket.readyState === WebSocket.OPEN) {
        gameSocket.send(JSON.stringify({
            'type': 'mastermind_select_player',
            'player_id': playerId
        }));
    } else {
        console.error('WebSocket not available for mastermind player selection');
    }
}

function sendReadyResponse(isReady) {
    console.log('Sending ready response:', isReady);
    
    if (gameSocket && gameSocket.readyState === WebSocket.OPEN) {
        gameSocket.send(JSON.stringify({
            'type': 'mastermind_gm_ready_response',
            'is_ready': isReady
        }));
    } else {
        console.error('WebSocket not available for ready response');
    }
}

function continueToNextPlayer() {
    console.log('Continuing to next player');
    
    if (gameSocket && gameSocket.readyState === WebSocket.OPEN) {
        gameSocket.send(JSON.stringify({
            'type': 'mastermind_continue_to_next_player'
        }));
    } else {
        console.error('WebSocket not available for continue to next player');
    }
}

// Initialize WebSocket connection
initWebSocket();

// Ensure display matches current template state (important after page refresh)
document.addEventListener('DOMContentLoaded', function() {
    const templateRoundType = '{{ round_info.round_type|default:"flower_fruit_veg" }}';
    const isRoundActive = {{ round_info.is_active|yesno:"true,false" }};
    const currentRoundNumber = {{ round_info.round_number|default:0 }};
    
    console.log('Page loaded with round type:', templateRoundType, 'Active:', isRoundActive, 'Round:', currentRoundNumber);
    
    if (templateRoundType !== currentRoundType) {
        console.log('Syncing round type from template');
        currentRoundType = templateRoundType;
        
        // Force a display update with current template data
        const templateData = {
            round_number: currentRoundNumber,
            round_type: templateRoundType,
            {% if round_info.round_type == 'multiple_choice' %}
            question_text: '{{ round_info.question_text|escapejs }}',
            choices: {{ round_info.choices|safe }},
            category: '{{ round_info.category|escapejs }}',
            {% else %}
            category: '{{ round_info.category.name|default:"Category"|escapejs }}',
            letter: '{{ round_info.prompt_letter|default:""|escapejs }}',
            prompt_letter: '{{ round_info.prompt_letter|default:""|escapejs }}',
            {% endif %}
        };
        
        console.log('Updating display with template data:', templateData);
        updateRoundDisplay({current_round: templateData});
    }
    
    // Auto-show answers if round is not active and we have a round number
    if (!isRoundActive && currentRoundNumber > 0) {
        console.log('üîç AUTO-SHOW: Round is not active, automatically showing answers');
        setTimeout(() => {
            showAnswers();
        }, 500); // Small delay to ensure page is fully loaded
    }
});

// Start countdown if round is active
{% if current_round.is_active %}
    startCountdown({{ config.round_time_seconds }});
{% endif %}
</script>
{% endblock %}
